1) Thread / Process / Task
Thread -> A thread is the smallest unit of execution that can be scheduled by the operating system. 
Process -> A process is a group of associated threads that execute in the same, shared environment. By shared environment, we mean that the threads in the same process share the same memory space and can communicate directly with one another.
Task -> A task is a single unit of work performed by a thread. A thread can complete multiple independent tasks but only one task at a time.

2) Single-threaded process / multi-threaded process
single-threaded process is one that contains exactly one thread.
multi-threaded process is one that contains one or more threads.

3) System Threads / user-defined threads  -- Types of threads
System Threads -> A system thread is created by the JVM and runs in the background of the application.
For example, the garbage-collection thread is a system thread that is created by the JVM and runs in the background, helping to free memory that is no longer in use. When a system-defined thread encounters a problem and cannot recover, such as running out of memory, it generates a Java Error , as opposed to an Exception. Even though it is possible to catch an Error, it is considered a very poor practice to do so, since it is rare that an application can recover from a system-level failure.
User-defined Thread -> A user-defined thread is one created by the application developer to accomplish a specific task.

4) Concurrency
-> The property of executing multiple threads and processes at the same time is referred to as concurrency.

5) How does the system decide what to execute when there are multiple threads available?
-> Operating systems use a thread scheduler to determine which threads should be currently executing. 
When a thread’s allotted time is complete but the thread has not finished processing, a context switch occurs. 
A thread can interrupt or supersede another thread if it has a higher thread priority than the other thread.

6) Context Switch
-> A context switch is the process of storing a thread’s current state and later restoring the state of the thread to continue execution. Be aware that there is often a cost associated with a context switch by way of lost time saving and reloading a thread’s state.

7) Round-Robin Scheduler
-> A thread scheduler may employ a round-robin schedule in which each available thread receives an equal number of CPU cycles with which to execute, 
with threads visited in a circular order. If there are 10 available threads, they might each get 100 milliseconds in which to execute, with the process returning to the first thread after the last thread has executed.

8) Thread Priority
-> A thread priority is a numeric value associated with a thread that is taken into consideration by the thread scheduler when determining which threads should currently be executing. By default, user-defined threads receive a thread priority value of Thread.NORM_PRIORITY. If two threads have the same priority, the thread scheduler will arbitrarily (randomly) choose the one to process first in most situations. 
Thread.MIN_PRIORITY (1) , Thread.NORM_PRIORITY (5) , Thread.MAX_PRIORITY (10)

9) Runnable
-> The interface Runnable is commonly used to define a thread task by creating a class that implements the Runnable interface. 
The Runnable interface is commonly used to define the work a thread will execute, separate from the main application thread.
Runnable is a functional interface that takes no arguments and returns no data.
@FunctionalInterface public interface Runnable {
	void run();
}

10) Runnable vs Thread
-> The following are some reasons to prefer one method over the other in Java:
■■ If you need to define your own Thread rules upon which multiple tasks will rely, such as a priority Thread, extending Thread may be preferable.
■■ Since Java doesn't support multiple inheritance, extending Thread does not allow you to extend any other class, whereas implementing Runnable lets you extend another class.
■■ Implementing Runnable is often a better object-oriented design practice since it separates the task being performed from the Thread object performing it.
■■ Implementing Runnable allows the class to be used by numerous Concurrency API classes. We can now use the ExecutorService, to perform thread tasks without having to create Thread objects directly.

11) Executor Service
-> The ExecutorService, is an interface, which creates and manages threads for you. You first obtain an instance of an ExecutorService interface, 
and then you send the service tasks to be processed. The framework includes numerous useful features, such as thread pooling and scheduling.
It is recommended that you use this framework anytime you need to create and execute a separate task, even if you need only a single thread.

12) Since ExecutorService is an interface, how do you obtain an instance of it?
-> The Concurrency API includes the Executors factory class that can be used to create instances of the ExecutorService object.
ex: ExecutorService service = Executors.newSingleThreadExecutor();
With a single-thread executor, results are guaranteed to be executed in the order in which they are added to the executor service.

13) Shutting Down a Thread Executor (ExecutorService) -- Can we use try-with-resources on ExecutorService?
-> Once you have finished using a thread executor, it is important that you call the shutdown() method. A thread executor creates a non-daemon thread on the first task that is executed, so failing to call shutdown() will result in your application never terminating.
The shutdown process for a thread executor involves first rejecting any new tasks submitted to the thread executor while continuing to execute any previously submitted tasks. 
During this time, calling isShutdown() will return true, while isTerminated() will return false. If a new task is submitted to the thread executor while it is shutting down, a RejectedExecutionException will be thrown. Once all active tasks have been completed, isShutdown() and isTerminated() will both return true.
Unfortunately, the ExecutorService interface does not implement AutoCloseable, so you cannot use a try-with-resources statement. You can still use a finally block to call shutdown().

14) Life cycle of an ExecutorService object
-> Active => Shutting Down => Shutdown
When a new thread executor is created, it is in "Active" state. In this state, it
- accepts new tasks
- execute tasks
- isShutdown() = false
- isTerminated() = false

When we call shutdown() method on executor, it will go into "Shutting Down" state. In this state, it
- Rejects new tasks
- Execute previous tasks
- isShutdown() = true
- isTerminated() = false

When all tasks finished, the executor will go into "Shutdown" state. In this state, it
- Rejects new tasks
- No tasks running
- isShutdown() = true
- isTerminated() = true

15) shutdown() vs shutdownNow()
-> shutdown() does not actually stop any tasks that have already been submitted to the thread executor. 
shutdownNow(), which attempts to stop all running tasks and discards any that have not been started yet. Note that shutdownNow() attempts to stop all running tasks. 
It is possible to create a thread that will never terminate, so any attempt to interrupt it may be ignored. Lastly, shutdownNow() returns a List<Runnable> of tasks 
that were submitted to the thread executor but that were never started.

16) Submitting tasks (ExecutorService methods)
-> execute(), submit(), invokeAll(), invokeAny()
Asynchronous - execute(), submit()
Synchronous - invokeAll(), invokeAny()

void execute(Runnable command)
Future<?> submit(Runnable task)
<T> Future<T> submit(Callable<T> task)
<T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException
<T> T invokeAny(Collection<? extends Callable<T>> tasks) throws InterruptedException,ExecutionException

17) execute() vs submit()
-> execute()
- execute(), is inherited from the Executor interface, which the ExecutorService interface extends.
- The execute() method takes a Runnable lambda expression or instance and completes the task asynchronously.
- Because the return type of the method is void, it does not tell us anything about the result of the task. It is considered a “fire-and-forget” method, 
as once it is submitted, the results are not directly available to the calling thread.

-> submit()
- submit() methods available in the ExecutorService interface.
- like execute(), submit() can be used to complete tasks asynchronously.
- Unlike execute(), submit() returns a Future object that can be used to determine if the task is complete. It can also be used to return a generic result object 
after the task has been completed (Callable).

-> The execute() and submit() methods are nearly identical when applied to Runnable expressions. The submit() method has the obvious advantage of doing
the exact same thing execute() does, but with a return object that can be used to track the result. Because of this advantage and the fact that execute() does not support Callable
expressions, we tend to prefer submit() over execute(), even if you don't store the Future reference.

18) invokeAll() vs invokeAny()
-> Both of these methods take a Collection object containing a list of tasks to execute.
Both of these methods also execute synchronously. By synchronous, we mean that, these methods will wait until the results are available before 
returning control to the enclosing program.

The invokeAll() method executes all tasks in a provided collection and returns a List of ordered Future objects, with one Future object corresponding to each submitted task, in the
order they were in the original collection. Even though Future.isDone() returns true for each element in the returned List, a task could have completed normally 
or thrown an exception.

The invokeAny() method executes a collection of tasks and returns the result of one of the tasks that successfully completes execution, cancelling all unfinished tasks. 

Finally, the invokeAll() method will wait indefinitely until all tasks are complete, while the invokeAny() method will wait indefinitely until at least one task completes.

19) How do we know when a task submitted to an ExecutorService is complete?
-> The submit() method returns a java.util.concurrent.Future<V> object, that can be used to determine this result:
Future<?> future = service.submit(() -> System.out.println("Hello Zoo"));
The Future class includes methods that are useful in determining the state of a task.
boolean isDone() - Returns true if the task was completed, threw an exception, or was cancelled.
boolean isCancelled() - Returns true if the task was cancelled before it completely normally.
boolean cancel() - Attempts to cancel execution of the task.
V get() - Retrieves the result of a task, waiting endlessly if it is not yet available.
V get(long timeout, TimeUnit unit) - Retrieves the result of a task, waiting the specified amount of time. If the result is not ready 
by the time the timeout is reached, a checked TimeoutException will be thrown.

20) What is the return value of this task?
-> Future<?> future = service.submit(() -> System.out.println("Rasool")); 
future.get() ==> returns null as the return type of Runnable.run() is void, the get() method always returns null.

-> Future<Integer> future = service.submit(() -> 5); 
future.get(); ==> returns 5 as the return type of Callable.call() is generic type (in this case it is Integer).

Unlike Runnable, in which the get() methods always return null, the get() methods on a Future object return the matching generic type or null.

21) Runnable vs Callable
-> java.util.concurrent.Callable, which is similar to Runnable except that its call() method returns a value and can throw a checked exception.
java.lang.Runnable, its run() method returns void and cannot throw any checked exceptions.

Runnable and Callable was made a functional interface in Java 8.

@FunctionalInterface public interface Callable<V> {
V call() throws Exception;
}

The Callable interface was introduced as an alternative to the Runnable interface, since it returns value from the task after it is completed.


22) Callable vs Supplier
-> Callable functional interface strongly resembles the Supplier functional interface, in that they both take no arguments and return a generic type. 
One difference is that the method in Callable can throw a checked Exception.

@FunctionalInterface
public interface Supplier<T> {
T get();
}





